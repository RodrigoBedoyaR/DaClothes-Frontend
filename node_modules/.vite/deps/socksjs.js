import {
  require_net
} from "./chunk-HRIZSLQL.js";
import {
  __commonJS
} from "./chunk-HM4MQYWN.js";

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports, module) {
    (function() {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;
      ipaddr = {};
      root = this;
      if (typeof module !== "undefined" && module !== null && module.exports) {
        module.exports = ipaddr;
      } else {
        root["ipaddr"] = ipaddr;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        var rangeName, rangeSubnets, subnet, _i, _len;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (toString.call(rangeSubnets[0]) !== "[object Array]") {
            rangeSubnets = [rangeSubnets];
          }
          for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
            subnet = rangeSubnets[_i];
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
        return defaultName;
      };
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          var octet, _i, _len;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (_i = 0, _len = octets.length; _i < _len; _i++) {
            octet = octets[_i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet is a byte");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string2) {
          if (string2[0] === "0" && string2[1] !== "x") {
            return parseInt(string2, 8);
          } else {
            return parseInt(string2);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            var _i, _len, _ref, _results;
            _ref = match.slice(1, 6);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              part = _ref[_i];
              _results.push(parseIntAuto(part));
            }
            return _results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          return function() {
            var _i, _results;
            _results = [];
            for (shift = _i = 0; _i <= 24; shift = _i += 8) {
              _results.push(value >> shift & 255);
            }
            return _results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts) {
          var part, _i, _len;
          if (parts.length !== 8) {
            throw new Error("ipaddr: ipv6 part count should be 8");
          }
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit to two octets");
            }
          }
          this.parts = parts;
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          var compactStringParts, part, pushPart, state, stringParts, _i, _len;
          stringParts = (function() {
            var _i2, _len2, _ref, _results;
            _ref = this.parts;
            _results = [];
            for (_i2 = 0, _len2 = _ref.length; _i2 < _len2; _i2++) {
              part = _ref[_i2];
              _results.push(part.toString(16));
            }
            return _results;
          }).call(this);
          compactStringParts = [];
          pushPart = function(part2) {
            return compactStringParts.push(part2);
          };
          state = 0;
          for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
            part = stringParts[_i];
            switch (state) {
              case 0:
                if (part === "0") {
                  pushPart("");
                } else {
                  pushPart(part);
                }
                state = 1;
                break;
              case 1:
                if (part === "0") {
                  state = 2;
                } else {
                  pushPart(part);
                }
                break;
              case 2:
                if (part !== "0") {
                  pushPart("");
                  pushPart(part);
                  state = 3;
                }
                break;
              case 3:
                pushPart(part);
            }
          }
          if (state === 2) {
            pushPart("");
            pushPart("");
          }
          return compactStringParts.join(":");
        };
        IPv6.prototype.toByteArray = function() {
          var bytes, part, _i, _len, _ref;
          bytes = [];
          _ref = this.parts;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toNormalizedString = function() {
          var part;
          return (function() {
            var _i, _len, _ref, _results;
            _ref = this.parts;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              part = _ref[_i];
              _results.push(part.toString(16));
            }
            return _results;
          }).call(this).join(":");
        };
        IPv6.prototype.match = function(other, cidrRange) {
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, _ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      ipv6Regexes = {
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), "i")
      };
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount;
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string[0] === ":") {
          colonCount--;
        }
        if (string[string.length - 1] === ":") {
          colonCount--;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        return function() {
          var _i, _len, _ref, _results;
          _ref = string.split(":");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            _results.push(parseInt(part, 16));
          }
          return _results;
        }();
      };
      ipaddr.IPv6.parser = function(string) {
        var match, parts;
        if (string.match(ipv6Regexes["native"])) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes["transitional"])) {
          parts = expandIPv6(match[1].slice(0, -1), 6);
          if (parts) {
            parts.push(parseInt(match[2]) << 8 | parseInt(match[3]));
            parts.push(parseInt(match[4]) << 8 | parseInt(match[5]));
            return parts;
          }
        }
        return null;
      };
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = ipaddr.IPv6.isValid = function(string) {
        var e;
        try {
          new this(this.parser(string));
          return true;
        } catch (_error) {
          e = _error;
          return false;
        }
      };
      ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isIPv6(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isIPv4(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(exports);
  }
});

// node_modules/socksjs/socks.js
var require_socks = __commonJS({
  "node_modules/socksjs/socks.js"(exports, module) {
    var stream = require_stream();
    var util = require_util();
    var net = require_net();
    var tls = require_tls();
    var ipaddr = require_ipaddr();
    var SocksConnection = function(remote_options, socks_options) {
      var that = this;
      stream.Duplex.call(this);
      this.remote_options = defaults(remote_options, {
        host: "localhost",
        ssl: false,
        rejectUnauthorized: false
      });
      socks_options = defaults(socks_options, {
        localAddress: "0.0.0.0",
        allowHalfOpen: false,
        host: "localhost",
        port: 1080,
        user: null,
        pass: null
      });
      this._socksSetup = false;
      this.socksAddress = null;
      this.socksPort = null;
      this.socksSocket = net.createConnection({
        host: socks_options.host,
        port: socks_options.port,
        localAddress: socks_options.localAddress,
        allowHalfOpen: socks_options.allowHalfOpen
      }, socksConnected.bind(this, !!socks_options.user));
      this.socksSocket.on("error", function(err) {
        that.emit("error", err);
      });
      socksAuth.call(this, { user: socks_options.user, pass: socks_options.pass });
      this.outSocket = this.socksSocket;
    };
    util.inherits(SocksConnection, stream.Duplex);
    SocksConnection.connect = function(remote_options, socks_options, connection_listener) {
      var socks_connection = new SocksConnection(remote_options, socks_options);
      if (typeof connection_listener === "function") {
        socks_connection.on("connect", connection_listener);
      }
      return socks_connection;
    };
    SocksConnection.prototype._read = function() {
      var data;
      if (this._socksSetup) {
        while ((data = this.outSocket.read()) !== null) {
          if (this.push(data) === false) {
            break;
          }
        }
      } else {
        this.push("");
      }
    };
    SocksConnection.prototype._write = function(chunk, encoding, callback) {
      if (this._socksSetup) {
        this.outSocket.write(chunk, "utf8", callback);
      } else {
        callback("Not connected");
      }
    };
    SocksConnection.prototype.dispose = function() {
      this.outSocket.destroy();
      this.outSocket.removeAllListeners();
      if (this.outSocket !== this.socksSocket) {
        this.socksSocket.destroy();
        this.socksSocket.removeAllListeners();
      }
      this.removeAllListeners();
    };
    var getData = function(socket, bytes, callback) {
      var dataReady = function() {
        var data = socket.read(bytes);
        if (data !== null) {
          socket.removeListener("readable", dataReady);
          callback(data);
        } else {
          socket.on("readable", dataReady);
        }
      };
      dataReady();
    };
    var socksConnected = function(auth) {
      if (auth) {
        this.socksSocket.write("\0");
      } else {
        this.socksSocket.write("\0");
      }
    };
    var socksAuth = function(auth) {
      var that = this;
      getData(this.socksSocket, 2, function(data) {
        if (data.readUInt8(0) !== 5) {
          that.emit("error", "Only SOCKS version 5 is supported");
          that.socksSocket.destroy();
          return;
        }
        switch (data.readUInt8(1)) {
          case 255:
            that.emit("error", "SOCKS: No acceptable authentication methods");
            that.socksSocket.destroy();
            return;
          case 2:
            that.socksSocket.write(Buffer.concat([
              new Buffer([1]),
              new Buffer([Buffer.byteLength(auth.user)]),
              new Buffer(auth.user),
              new Buffer([Buffer.byteLength(auth.pass)]),
              new Buffer(auth.pass)
            ]));
            socksAuthStatus.call(that);
            break;
          default:
            socksRequest.call(that, that.remote_options.host, that.remote_options.port);
        }
      });
    };
    var socksAuthStatus = function(data) {
      var that = this;
      getData(this.socksSocket, 2, function(data2) {
        if (data2.readUInt8(1) === 0) {
          socksRequest.call(that, that.remote_options.host, that.remote_options.port);
        } else {
          that.emit("error", "SOCKS: Authentication failed");
          that.socksSocket.destroy();
        }
      });
    };
    var socksRequest = function(host, port) {
      var header, type, hostBuf, portBuf;
      if (net.isIP(host)) {
        if (net.isIPv4(host)) {
          type = new Buffer([1]);
        } else if (net.isIPv6(host)) {
          type = new Buffer([4]);
        }
        hostBuf = new Buffer(ipaddr.parse(host).toByteArray());
      } else {
        type = new Buffer([3]);
        hostBuf = new Buffer(host);
        hostBuf = Buffer.concat([new Buffer([Buffer.byteLength(host)]), hostBuf]);
      }
      header = new Buffer([5, 1, 0]);
      portBuf = new Buffer(2);
      portBuf.writeUInt16BE(port, 0);
      this.socksSocket.write(Buffer.concat([header, type, hostBuf, portBuf]));
      socksReply.call(this);
    };
    var socksReply = function(data) {
      var that = this;
      getData(this.socksSocket, 4, function(data2) {
        var status, err, cont;
        cont = function(addr, port) {
          that.socksAddress = addr;
          that.socksPort = port;
          if (that.remote_options.ssl) {
            startTLS.call(that);
          } else {
            proxyData.call(that);
            that.emit("connect");
          }
        };
        status = data2.readUInt8(1);
        if (status === 0) {
          switch (data2.readUInt8(3)) {
            case 1:
              getData(that.socksSocket, 6, function(data22) {
                var addr = "", port, i;
                for (i = 0; i < 4; i++) {
                  if (i !== 0) {
                    addr += ".";
                  }
                  addr += data22.readUInt8(i).toString();
                }
                port = data22.readUInt16BE(4);
                cont(addr, port);
              });
              break;
            case 3:
              getData(that.socksSocket, 1, function(data22) {
                var length = data22.readUInt8(0);
                getData(that.socksSocket, length + 2, function(data3) {
                  var addr, port;
                  addr = data3.slice(0, -2).toString();
                  port = data3.readUInt16BE(length);
                  cont(addr, port);
                });
              });
              break;
            case 4:
              getData(that.socksSocket, 18, function(data22) {
                var addr = "", port, i;
                for (i = 0; i < 16; i++) {
                  if (i !== 0) {
                    addr += ":";
                  }
                  addr += data22.readUInt8(i);
                }
                port = data22.readUInt16BE(16);
                cont(addr, port);
              });
              break;
            default:
              that.emit("error", "Invalid address type");
              that.socksSocket.destroy();
              break;
          }
        } else {
          switch (status) {
            case 1:
              err = "SOCKS: general SOCKS server failure";
              break;
            case 2:
              err = "SOCKS: Connection not allowed by ruleset";
              break;
            case 3:
              err = "SOCKS: Network unreachable";
              break;
            case 4:
              err = "SOCKS: Host unreachable";
              break;
            case 5:
              err = "SOCKS: Connection refused";
              break;
            case 6:
              err = "SOCKS: TTL expired";
              break;
            case 7:
              err = "SOCKS: Command not supported";
              break;
            case 8:
              err = "SOCKS: Address type not supported";
              break;
            default:
              err = "SOCKS: Unknown error";
          }
          that.emit("error", err);
        }
      });
    };
    var startTLS = function() {
      var that = this;
      var plaintext = tls.connect({
        socket: this.socksSocket,
        rejectUnauthorized: this.remote_options.rejectUnauthorized,
        key: this.remote_options.key,
        cert: this.remote_options.cert,
        requestCert: this.remote_options.requestCert
      });
      plaintext.on("error", function(err) {
        that.emit("error", err);
      });
      plaintext.on("secureConnect", function() {
        that.emit("connect");
      });
      this.outSocket = plaintext;
      this.getPeerCertificate = function() {
        return plaintext.getPeerCertificate();
      };
      proxyData.call(this);
    };
    var proxyData = function() {
      var that = this;
      this.outSocket.on("readable", function() {
        var data;
        while ((data = that.outSocket.read()) !== null) {
          if (that.push(data) === false) {
            break;
          }
        }
      });
      this.outSocket.on("end", function() {
        that.push(null);
      });
      this.outSocket.on("close", function(had_err) {
        that.emit("close", had_err);
      });
      this._socksSetup = true;
    };
    var defaults = function(obj) {
      Array.prototype.slice.call(arguments, 1).forEach(function(source) {
        if (source) {
          for (var prop in source) {
            if (obj[prop] === null) {
              obj[prop] = source[prop];
            }
          }
        }
      });
      return obj;
    };
    module.exports = SocksConnection;
  }
});
export default require_socks();
//# sourceMappingURL=socksjs.js.map
